[{"uri":"https://hotloncon1.github.io/aws-lab000052/vi/","title":"Tạo một Microservice","tags":[],"description":"","content":"Tạo một Microservice Tổng quan Trong phần này, bạn sẽ học cách tạo một hàm AWS Lambda được kích hoạt khi có tập tin được tải lên Amazon S3 Bucket. Bạn sẽ tải đoạn mã nguồn lên hàm Lambda, sau đó kết nối thủ công tới một trình kích hoạt sự kiện S3 để gọi hàm và xem log đầu ra. Sau đó, bạn sẽ chỉnh sửa lại code và thêm các chức năng cho phép nó xử lý các loại tập tin khác nhau - cụ thể là tạo hình thu nhỏ cho các hình ảnh JPG và xóa tất cả các loại tệp khác. Cuối cùng, bạn sẽ tạo một gói triển khai và tự động hóa việc triển khai hàm cũng như các trình kích hoạt liên quan và S3 bucket, sử dụng AWS CLI.\nNội dung: Giới thiệu Chuẩn bị Tạo một microservice Mở rộng Serverless Microservices Cấu hình điều phối với CodeStar Thử thách - Expose microservice API Dọn dẹp tài nguyên "},{"uri":"https://hotloncon1.github.io/aws-lab000052/vi/1-introduction/","title":"Giới thiệu","tags":[],"description":"","content":"Giới thiệu Trong phần này, bạn sẽ học cách tạo một hàm AWS Lambda được kích hoạt khi có tập tin được tải lên Amazon S3 Bucket. Bạn sẽ tải đoạn mã nguồn lên hàm Lambda, sau đó kết nối thủ công tới một trình kích hoạt sự kiện S3 để gọi hàm và xem log đầu ra. Sau đó, bạn sẽ chỉnh sửa lại code và thêm các chức năng cho phép nó xử lý các loại tập tin khác nhau - cụ thể là tạo hình thu nhỏ cho các hình ảnh JPG và xóa tất cả các loại tệp khác. Cuối cùng, bạn sẽ tạo một gói triển khai và tự động hóa việc triển khai hàm cũng như các trình kích hoạt liên quan và S3 bucket, sử dụng AWS CLI.\nPhiên bản cuối cùng của hàm AWS Lambda thực hiện những nhiệm vụ sau đây:\nĐầu tiên, tải một tập tin lên S3 bucket. Amazon S3 kích hoạt hàm AWS Lambda được liên kết với hành động PutObject và cung cấp metadata để mô tả tập tin. Hàm Lambda kiểm tra loại nội dung của tập tin và nếu nó không phải là tập tin image/jpeg, tập tin sẽ bị xóa. Nếu tập tin là tập tin image/jpeg, đoạn code sẽ sinh ra một tập tin thu nhỏ của hình ảnh và lưu hình thu nhỏ này ở một thư mục khác trong cùng một bucket. Sau đó, bạn sẽ quay trở lại với ứng dụng web TravelBuddy và triển khai các phần monolithic codebase như một microservices độc lập, sử dụng AWS CodeStar để tạo CI/CD pipeline.\nNội dung Sau khi hoàn thành bài thực hành, bạn sẽ có thể:\nSử dụng Eclipse IDE để tạo một AWS Lambda function và triển khai. Chỉnh sửa mã nguồn hàm Java Lambda đã được cung cấp để thay đổi kích thước hình ảnh dưới dạng hình thu nhỏ hoặc xóa tập tin không phải hình ảnh và kết nối trình kích hoạt vào S3 bucket để kiểm tra tính năng. Sử dụng AWS Serverless Application Model (SAM) và AWS CloudFormation để tạo template nhằm tự động hóa việc triển khai hàm Lambda, S3 trigger và S3 bucket. Xác định microservice candidate trong monolithic codebase và tạo dự án AWS CodeStar để quản lý CI/CD pipeline cho microservice đó được lưu trữ trong AWS Lambda. Kiến thức kỹ thuật cần có Để có thể hoàn thành bài thực hành này, bạn nên làm quen với:\nNhững điều hướng cơ bản của AWS Management Console. Chỉnh sửa tập lệnh bằng trình soạn thảo. Sử dụng Eclipse IDE và ngôn ngữ lập trình Java Môi trường Sơ đồ sau miêu tả các tài nguyên được triển khai trong bài thực hành này. "},{"uri":"https://hotloncon1.github.io/aws-lab000052/vi/2-prepare/2.1-createkeypair/","title":"Tạo Key Pair","tags":[],"description":"","content":"Tạo Key Pair Truy cập Amazon EC2 console. Trên thanh điều hướng bên trái, chọn Key Pairs. Chọn Create key pair. Tại trang Create key pair Tại mục Name, điền KPforDevAxInstances Tại mục Key pair type, chọn RSA Tại mục Private key file format, chọn .pem Click Create key pair Lưu file key pair để dùng ở các bước tiếp theo. "},{"uri":"https://hotloncon1.github.io/aws-lab000052/vi/5-use-codestar-orchestration/5.1-create-new-branch/","title":"Tạo nhánh mới","tags":[],"description":"","content":"Tạo nhánh mới Bây giờ bạn đã có kinh nghiệm thực tế về việc tạo và triển khai các hàm AWS Lambda, đã đến lúc quay lại ứng dụng TravelBuddy monolithic của chúng ta và triển khai một microservice trên AWS Lambda được quản lý thông qua CI/CD pipeline được tạo bằng AWS CodeStar.\nTruy cập AWS CodeStar Console. Click Projects Click Create project Click Create service role nếu đây là lần đầu bạn truy cập vào dịch vụ AWS CodeStar.\nTrong phần Templates, chọn Java, Web Service và AWS Lambda Chọn Java Spring Click Next Tại mục Project name, nhập dev-flight-svc Chọn Code Commit Click Next Tại trang Review, click Create project Thêm tài khoản awsstudent vào Team với vai trò Owner. Click Team Click Add team member Trong phần Team member details Tại mục User, chọn awsstudent Tại mục Email address, điền email của bạn Tại mục Project role, chọn Owner CLick Allow SSH access to project instances. Click Add team member Kiểm tra team member được add vào thành công Truy cập AWS CloudFormation Console. Nhập aws-stack-for-Devax-lab03 vào ô tìm kiếm và nhấn Enter. Click aws-stack-for-Devax-lab03. Click Output Lưu lại giá trị GitPassword và GitUserName Trong Eclipse IDE, tìm biểu tượng AWS và nhấp vào mũi tên thả xuống Click Import AWS CodeStar Project Chọn Region chúng ta đang sử dụng Chọn dev-flight-svc Điền thông tin đã lưu trong bước 9 vào phần User name và Password Click Next Click OK, bỏ qua lỗi org.eclipse.egit.ui.internal.repository.tree.RepositoryTreeNodeType.getIcon()Lorg/eclipse/swt/graphics/Image; Chọn branch master Click Next. Click Finish Click No để bỏ qua thiết lập password hint. Hãy dành một ít thời gian để xem cấu trúc project trước khi tiếp tục. Microservice HelloWorld biểu diễn một xử lý đơn giản, trả về trang web Hello World khi được gọi. "},{"uri":"https://hotloncon1.github.io/aws-lab000052/vi/3-create-serverless-microservices/3.1-create-lambda-function/","title":"Tạo và kiểm tra hàm Lambda tại cục bộ","tags":[],"description":"","content":"Tạo và kiểm tra hàm Lambda tại cục bộ Mở Eclipse IDE trong máy ảo Windows. Tìm biểu tượng AWS, nhấp vào mũi tên thả xuống Click New AWS Lambda Java Project… Trong hộp thoại New AWS Lambda Maven Project Tại mục Project name, gõ TestLambda Tại mục Group ID, gõ idevelop.lambda Tại mục Artifact ID, gõ s3handler Click Finish Chúng ta cần cập nhật tập tin pom.xml mà Maven sử dụng lên phiên bản Mockito mới hơn Mở project TestLambda Mở file pom.xml Tìm phần dependency có artifactId là mockito-core và thay phần version thành 3.3.3 Lưu lại Chạy JUnit Test Nhấp chuột phải vào thư mục root của project TestLambda. Click Run As Click JUnit Test Bạn sẽ thấy kết quả đầu ra từ hàm lambda, như thể nó được kích hoạt bởi một tập tin được tải lên S3. Các tham số cho bài test được cung cấp trong test resource, ở dạng JSON payload giống với payload mà môi trường Amazon sẽ gửi đến hàm Lambda, khi S3 bucket được liên kết với hàm Lambda này nhận được tập tin được tải lên. Bạn có thể sẽ thấy một vài cảnh báo liên quan tới profile name. Bạn có thể bỏ qua cảnh báo này trong bài thực hành này.\nĐể xem kết quả đầu ra của phần JUnit test, click tab JUnit Kiểm tra tập tin S3-event.put.json có đường dẫn TestLambda/src/test/resources/s3-event.put.json. Tập tin S3-event.put.json chứa những schema và giá trị mà chúng ta sẽ sử dụng cho bài thực hành này. Bạn có thể sẽ thấy một cảnh báo liên quan tới việc thiếu node. Bạn có thể bỏ qua cảnh báo này bằng cách click OK\nCập nhật code được cung cấp để xử lý các URL encoded keys Mã nguồn được cung cấp không quan tâm tới việc mã hóa được áp dụng cho key name được cung cấp trong S3 event khi nó được gửi tới hàm Lambda, do đó nếu bạn tải một tập tin để kiểm tra, và tập tin chứa khoảng trắng hoặc dấu cấu thì chuỗi này cần được decode trước khi sử dụng.\nMở LambdaFunctionHandler.java có đường dẫn src/main/java/idevelop.lambda.s3handler/LambdaFunctionHandler.java Thêm đoạn code sau vào sau dòng 28 và lưu lại try { key = java.net.URLDecoder.decode(key, \u0026#34;UTF-8\u0026#34;); } catch(Exception ex) { context.getLogger().log(\u0026#34;Could not decode URL for keyname... continuing...\u0026#34;); } "},{"uri":"https://hotloncon1.github.io/aws-lab000052/vi/4-extending-serverless-microservices/4.1-deploy-imagemanager-lambda/","title":"Triển khai hàm Lambda ImageManager ","tags":[],"description":"","content":"Triển khai hàm Lambda ImageManager Bạn sẽ chỉnh sửa đoạn code trong handleRequest trong tập tin LambdaFunctionHandler.java để những tập tin có contentType không phải là image/jpeg sẽ bị xóa bởi hàm Lambda. Điều này mô phỏng một tình huống, trong đó nếu có một tập tin tải lên sai content type, tập tin này sẽ bị loại bỏ và không xử lý. Nếu tập tin đó là image/jpeg, hàm Lambda sẽ thu nhỏ hình ảnh và chuyển hình thu nhỏ tới một target bucket để ứng dụng có thể sử dụng chúng.\nMở file LambdaFunctionHandler.java có đường dẫn src/main/java/idevelop.lambda.s3handler/LambdaFunctionHandler.java Tìm dòng code dưới đây context.getLogger().log(\u0026#34;CONTENT TYPE: \u0026#34; + contentType); Sau dòng code trên, thêm đoạn code sau để gọi 2 xử lý - một cho tập tin hình ảnh và một cho các tập tin không phải hình ảnh switch ( contentType ) { case \u0026#34;application/x-directory\u0026#34;: System.out.println(\u0026#34;application/x-directory detected - ignoring\u0026#34;); break; case \u0026#34;image/jpeg\u0026#34;: System.out.println(\u0026#34;image/jpeg detected\u0026#34;); InputStream objectData = null; objectData = response.getObjectContent(); handleJPEG(bucket, key, objectData); break; default: handleAllOtherContentTypes(bucket, key); break; } 2. Thêm đoạn code dưới đây vào cuối của class LambdaFunctionHandler\nprivate void handleJPEG(String bucketName, String key, InputStream imageStream) { final int THUMBNAIL_WIDTH = 100; final int THUMBNAIL_HEIGHT= 100; try { System.out.println(\u0026#34;Starting resize process...\u0026#34;); System.out.println(String.format( \u0026#34;Starting resize process for %s/%s of type image/jpg\u0026#34;, bucketName, key)); // Resize the image System.out.println(\u0026#34; Reading image stream from S3\u0026#34;); BufferedImage image = ImageIO.read(imageStream); System.out.println(\u0026#34; done\u0026#34;); final BufferedImage thumbnailImage = new BufferedImage(THUMBNAIL_WIDTH, THUMBNAIL_HEIGHT, BufferedImage.TYPE_INT_RGB); final Graphics2D graphics2D = thumbnailImage.createGraphics(); graphics2D.setComposite(AlphaComposite.Src); graphics2D.setRenderingHint(RenderingHints.KEY_INTERPOLATION,RenderingHints.VALUE_INTERPOLATION_BILINEAR); graphics2D.setRenderingHint(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_QUALITY); graphics2D.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON); System.out.println(\u0026#34; Drawing image...\u0026#34;); graphics2D.drawImage(image, 0, 0, THUMBNAIL_WIDTH, THUMBNAIL_HEIGHT, null); System.out.println(\u0026#34; done\u0026#34;); graphics2D.dispose(); System.out.println(\u0026#34; Opening output file...\u0026#34;); File fileThumbnail = new File(\u0026#34;/tmp/thumbnail.jpg\u0026#34;); System.out.println(\u0026#34; done\u0026#34;); System.out.println(\u0026#34; Writing output file...\u0026#34;); ImageIO.write(thumbnailImage, \u0026#34;jpg\u0026#34;, fileThumbnail); System.out.println(\u0026#34; done\u0026#34;); // // Now put the finished object into the /processed subfolder // Note that the filename manipulation here is not meant to be // production-ready and robust! It will break if files without extensions // are uploaded! // String fileName = key.substring( key.lastIndexOf(\u0026#39;/\u0026#39;) + 1, key.length() ); String fileNameWithoutExtn = fileName.substring(0, fileName.lastIndexOf(\u0026#39;.\u0026#39;)); System.out.println(\u0026#34; Pushing output file to processed folder...\u0026#34;); s3.putObject(bucketName, \u0026#34;processed/\u0026#34; + fileNameWithoutExtn + \u0026#34;.thumb.jpg\u0026#34;, fileThumbnail); System.out.println(\u0026#34; done\u0026#34;); } catch(Exception e) { System.out.println(String.format( \u0026#34;Error processing JPEG image from stream for %s/%s\u0026#34;, bucketName, key)); System.out.println(e.getMessage()); } finally { System.out.println(\u0026#34;Ended resize\u0026#34;); } } private void handleAllOtherContentTypes(String bucketName, String key) { System.out.println(String.format( \u0026#34;%s/%s is an unsupported file type. It will be deleted.\u0026#34;, bucketName, key)); s3.deleteObject(bucketName, key); System.out.println(\u0026#34; Done!\u0026#34;); } 3. Thêm đoạn code sau vào phần import ở đầu file LambdaFunctionHandler.java và lưu lại\nimport java.awt.AlphaComposite; import java.awt.Graphics2D; import java.awt.RenderingHints; import java.awt.image.BufferedImage; import java.io.File; import java.io.InputStream; import javax.imageio.ImageIO; LambdaFunctionHandler file LambdaFunctionHandler.java (5 KB) Nếu gặp khó khăn, bạn có thể tham khảo file LambdaFunctionHandler.java mẫu ở trên. Trong Command Prompt, chuyển đường dẫn đến project TestLambda Chạy lệnh dưới đây để build project mvn package Kết quả trả về một tập tin có tên s3handler-1.0.0.jar trong thư mục target của project TestLambda Truy cập AWS Lambda Console Click Functions. Nhập TestLambda vào ô tìm kiếm và nhấn Enter. Click TestLambda Để cung cấp function package, trong phần Code soure Click Upload from Click .zip or .jar file Click Upload, Chọn file s3handler-1.0.0.jar trong thư mục target của project TestLambda Click Save Sẽ mất một chút thời gian để tải lên Truy cập AWS S3 Console Nhập idevelop-imagemanager vào ô tìm kiếm Click S3 bucket có tên bắt đầu bằng idevelop-imagemanager Click thư mục uploads/ Click Upload Click Add files Chọn file Puppy.jpg chúng ta đã tải về Click Upload Click Close Click idevelop-imagemanager- Click vào thư mục processed Chúng ta đã tải ảnh Puppy.jpg lên thư mục uploads. Chúng ta sẽ thấy có một hình ảnh thu nhỏ được tạo và lưu trữ tại thư mục processed/. Thư mục processed/ sẽ được tạo tự động bởi hàm Lambda khi nó tạo các hình ảnh thu nhỏ. Truy cập AWS Lambda Console Click Functions. Nhập TestLambda vào ô tìm kiếm và nhấn Enter. Click TestLambda Click Monitor Click View logs in CloudWatch Click Log stream đầu tiên trong bảng Log streams Chúng ta hãy xem quá trình diễn ra như thế nào trong CloudWatch logs Tải lên một tập tin bất kỳ không phải hình ảnh vào thư mục uploads/ (làm tương tự bước 10, 11, 12 và 13) Click Close Ta sẽ thấy rằng tệp tin Module1.template.yaml vừa tải lên đã bị xóa Tệp tin Module3.template.yaml chúng ta đã tải lên trước khi cập nhật lại hàm Lambda nên nó không bị xóa\nLàm tương tự bước 18, 19, 20 và 21 để xem quá trình thực hiện như thế nào trong CloudWatch log. Truy cập AWS S3 Console Nhập idevelop-imagemanager vào ô tìm kiếm Click S3 bucket có tên bắt đầu bằng idevelop-imagemanager Click thư mục processed/ Click tệp tin Puppy.thumb.jpg Click link trong mục Object URL Chúng ta sẽ nhận được thông báo Access Denied vì S3 bucket policy chưa cho phép người dùng ẩn danh có thể có truyền đọc các tập tin trong bucket. Click idevelop-imagemanager Chọn thư mục processed/ Click Actions Click Make public using ACL Click Make public Truy cập lại vào tệp tin. Bây giờ ta đã có thể xem được nội dung của tập tin. "},{"uri":"https://hotloncon1.github.io/aws-lab000052/vi/2-prepare/","title":"Chuẩn bị","tags":[],"description":"","content":"Tổng quan Trong phần này chúng ta sẽ thực hiện tạo môi trường cho workshop bao gồm việc tạo Key Pair, tạo CloudFormation stack, kết nối Windows instance và cài đặt S3 buckets.\nNội dung: Tạo Key Pair Tạo CloudFormation stack Kết nối Windows instance Cài đặt S3 buckets "},{"uri":"https://hotloncon1.github.io/aws-lab000052/vi/3-create-serverless-microservices/3.2-update-and-test/","title":"Tải lên và kiểm tra hàm Lambda trong AWS Lambda ","tags":[],"description":"","content":"Tải lên và kiểm tra hàm Lambda trong AWS Lambda Nhấp chuột phải bên trong cửa sổ chứa mã nguồn của LambdaFunctionHandler.java trong src/main/java/idevelop.lambda.s3handler. Click AWS Lambda Click Run function on AWS Lambda… Click Upload now Chọn region đang thực hiện bài thực hành Chọn Create a new Lambda function. Nhập tên hàm Lambda là TestLambda Click Next Tại mục description, nhập Test AWS Lambda function triggered by S3 upload Tại mục IAM role, chọn LambdaRole được tạo tự động trong phần cấu hình bài thực hành. Tại mục S3 bucket, chọn S3 bucket có tên bắt đầu bằng idevelop-sourcecode- chúng ta đã tạo từ trước để chứa mã nguồn Lambda. Chọn Finish để tải hàm Lambda lên AWS Account. Việc tải lên sẽ tốn một vài phút. Truy cập AWS Lambda Console Click Functions. Nhập TestLambda vào ô tìm kiếm và nhấn Enter .Chúng ta sẽ thấy hàm TestLambda vừa được tải lên. Click hàm TestLambda Click Add Triggers Tại mục Trigger configuration, chọn S3 Tại mục Bucket, chọn bucket có tên bắt đầu bằng idevelop-imagemanager- mà bạn đã tạo để chứa hình ảnh tải lên Tại mục Event type chọn All Object create events Tại mục Prefix nhập uploads/. Không đặt giá trị Suffix. Click I acknowledge that using the same S3 bucket for both input and output is not recommended and that this configuration can cause recursive invocations, increased Lambda usage, and increased costs. Click Add Bây giờ chúng ta sẽ cùng kiểm tra hàm Lambda. Truy cập AWS S3 Console Nhập idevelop-imagemanager vào ô tìm kiếm Click S3 bucket có tên bắt đầu bằng idevelop-imagemanager Click Create folder Trong trang Create folder Tại mục Folder name, điền uploads Click Create folder Click uploads/ để mở folder uploads Puppy image Puppy.jpg (125 KB) Tải tệp tin Puppy.jpg\nClick Upload Click Add files\nChọn file Puppy.jpg đã tải trong bước 12 Click Upload Khi việc tải lên được hoàn tất Truy cập AWS Lambda Console Click Funtions Nhập TestLambda vào ô tìm kiếm và nhấn Enter Click TestLambda Click tab Monitor Bạn sẽ thấy 2 lệnh gọi và thời lượng của chúng trong biểu đồ. Bạn thấy 2 lệnh gọi - một là tạo thư mục uploads và một là tải lên hình ảnh Puppy.jpg Click View logs in CloudWatch để mở CloudWatch logs của hàm Lambda này. Chúng ta sẽ thấy có log streams được ghi lại Click vào log steam đầu tiên để xem thông tin chi tiết Bạn sẽ thấy CONTENT TYPE output khác nhau ở 2 sự kiện này. Trong sự kiện đầu tiên, CONTENT TYPE là application/x-directory và ở sự kiện thứ 2 là image/jpeg. Trong mã nguồn mẫu của hàm Lambda đã cung cấp, chỉ ghi logs CONTENT TYPE của tập tin mà không thực hiện hành động nào khác. Chúng ta sẽ thay đổi đoạn code này trong các phần tiếp theo.\nTải một tập tin bất kỳ không phải là hình ảnh lên S3 bucket và quan sát log (làm tương tự bước 13 và 14). Quan sát log (làm tương tự bước 15, 16 và 17) "},{"uri":"https://hotloncon1.github.io/aws-lab000052/vi/2-prepare/2.2-createstack/","title":"Tạo CloudFormation stack","tags":[],"description":"","content":"Tạo CloudFormation stack Template File Module3.template.yaml (39 KB) Tải tệp tin Module3.template.yaml. Truy cập Amazon CloudFormation Console. Click Stacks Click Create stack. Click With new resources (standard). Trong phần Specify template. Chọn Upload a template file Click Choose file, sau đó chọn tệp tin Module3.template.yaml chúng ta đã tải về. Click Next. Trong phần Stack name gõ aws-stack-for-Devax-lab03. Trong phần EEKeyPair chọn KPforDevAxInstances. Click Next. Tại trang Configure stack options, Kéo màn hình xuống dưới sau đó Click Next. Tại trang Review. Kéo màn hình xuống dưới sau đó Click I acknowledge that AWS CloudFormation might create IAM resources with custom names. Click Create stack. Cloudformation sẽ mất khoảng 5 phút để tạo stack . Hãy đợi cho đến khi tất cả các stack ở trạng thái CREATE_COMPLETE.\n"},{"uri":"https://hotloncon1.github.io/aws-lab000052/vi/5-use-codestar-orchestration/5.2-redeploy-through-cicd-pipeline/","title":"Triển khai lại thông qua CI/CD pipeline ","tags":[],"description":"","content":"Triển khai lại thông qua CI/CD pipeline Trong Command Prompt, chuyển đường dẫn đến project dev-flight-svc Chạy câu lệnh dưới đây để tạo nhánh mới git checkout -b \u0026#34;new-implementation\u0026#34; FlightSpecials file FlightSpecials.zip (8525 KB) Tải file FlightSpecials.zip Giải nén Copy toàn bộ nội dung của project FlightSpecials sau khi giải nén Trong Eclipse IDE, nhấp chuột phải vào project dev-flight-svc. Click Show In Click System Explorer. Xóa nội dung trong hai thư mục /src và /target của project dev-flight-svc trước khi copy đè lên. Dán đè nội dung của project FlightSpecials vào thư mục đã mở trong bước 3 Nếu bạn không xóa nội dung hai thư mục /src và /target trước khi copy code mới vào thì quá trình build sẽ bị lỗi vì chúng ta không cấu hình cho HelloWorldController / Handler.\nTrong Eclipse IDE, nhấp chuột phải vào project dev-flight-svc. Click Maven Click Update Project\u0026hellip; Click OK Là một phần của cài đặt microservice, chúng ta sử dụng VPC và gán một IAM Role mới cho hàm Lambda để cho phép nó thực hiện các tác vụ khác nhau. Khi CodeStar tạo project, nó tạo một IAM Role cấp đủ quyền cho CloudFormation để triển khai dịch vụ HelloWorld. Các quyền này không đủ cho các yêu cầu cao hơn, do đó, chúng ta cần thay đổi policy để gán quyền cho CloudFormation để mở rộng các quyền.\nTruy cập vào AWS IAM Console. Click Roles. Nhập CodeStarWorker-dev-flight-svc-CloudFormation vào ô tìm kiếm Click CodeStarWorker-dev-flight-svc-CloudFormation Click Add permissions Click Create inline policy Click tab JSON Dán đoạn mã sau đây vào { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Action\u0026#34;: [ \u0026#34;iam:GetRole\u0026#34;, \u0026#34;iam:CreateRole\u0026#34;, \u0026#34;iam:DeleteRole\u0026#34;, \u0026#34;iam:PassRole\u0026#34;, \u0026#34;iam:PutRolePolicy\u0026#34;, \u0026#34;iam:DeleteRolePolicy\u0026#34;, \u0026#34;lambda:ListTags\u0026#34;, \u0026#34;lambda:TagResource\u0026#34;, \u0026#34;lambda:UntagResource\u0026#34;, \u0026#34;lambda:AddPermission\u0026#34;, \u0026#34;ec2:DescribeSecurityGroups\u0026#34;, \u0026#34;ec2:DescribeSubnets\u0026#34;, \u0026#34;ec2:DescribeVpcs\u0026#34;, \u0026#34;ec2:CreateNetworkInterface\u0026#34;, \u0026#34;ec2:AttachNetworkInterface\u0026#34;, \u0026#34;ec2:DescribeNetworkInterfaces\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34; } ] } Click Review policy Tại mục Name, nhập idevelopCodeStarCloudFormationPolicy Click Create policy Khi thêm vai trò CodeStarWorker-dev-flight-svc-CloudFormation các quyền trong idevelopCodeStarCloudFormationPolicy policy cho phép CLoudFormation hành động thay mặt bạn khi các triển khai thay đổi trong môi trường, bao gồm quyền cho phép hàm Lambda gắn với VPC nơi RDS instance lưu trữ trang web TravelBuddy được triển khai. Chúng cũng cho phép CloudFormation tạo một IAM Role mới mà hàm Lambda sử dụng để thực thi.\nTập tin CloudFormation template template.yml được cung cấp trong FlightSpecials.zip có một vài giá trị cần cập nhật trước khi tiến hành triển khai. Những giá trị này bao gồm Subnet Ids, Security Group Ids and the RDS Instance Endpoint. Truy cập Amazon EC2 console. Click Security Groups. Nhập DBSecurityGroup vào ô tìm kiếm và nhấn Enter Lưu lại giá trị Security Group Id của DBSecurityGroup Truy cập Amazon VPC console. Click Subnets. Nhập Module3/DevAxNetworkVPC/privateSubnet vào ô tìm kiếm và nhấn Enter Lưu lại giá trị Subnet ID của subnet Module3/DevAxNetworkVPC/privateSubnet1 và subnet Module3/DevAxNetworkVPC/privateSubnet2 Truy cập AWS CloudFormation Console. Nhập aws-stack-for-Devax-lab03 vào ô tìm kiếm và nhấn Enter. Click aws-stack-for-Devax-lab03. Click Output Lưu lại giá trị RDSEndpoint Trong Eclipse IDE, mở file template.yml Thay sg-\u0026lt;REPLACE\u0026gt; bằng giá trị Security Group Id của DBSecurityGroup đã lưu trong bước 11 Thay subnet-\u0026lt;REPLACE\u0026gt; lần lượt bằng giá trị Subnet ID của subnet Module3/DevAxNetworkVPC/privateSubnet1 và subnet Module3/DevAxNetworkVPC/privateSubnet2 đã lưu trong bước 12 Thay \u0026lt;RDSEndpoint\u0026gt; bằng giá trị RDSEndpoint đã lưu trong bước 14 Lưu lại "},{"uri":"https://hotloncon1.github.io/aws-lab000052/vi/4-extending-serverless-microservices/4.2-automating-your-microservice/","title":"Tự động hóa Serverless Microservice","tags":[],"description":"","content":"Tự động hóa Serverless Microservice Trong bài tập trước, bạn đã sử dụng IDE Eclipse để tạo một hàm Lambda bằng Bộ công cụ AWS cho Eclipse và cập nhật một hàm Lambda. Điều này cho phép bạn khởi tạo việc tự động tải lên hàm Lambda của mình theo cách thủ công. Tuy nhiên, cơ chế này có thể không thuận tiện cho việc tự động hóa các bước triển khai cho các hàm hoặc phối hợp triển khai và cập nhật cho các phần tử khác của ứng dụng serverless, chẳng hạn như event sources và downstream resources. Ví dụ: IDE Eclipse không cung cấp cho bạn khả năng triển khai và cập nhật S3 bucket và kết nối S3 PUT OBJECT trigger, cùng với hàm Lambda của bạn như một đơn vị triển khai.\nBạn có thể sử dụng AWS CloudFormation để dễ dàng chỉ định, triển khai và định cấu hình các ứng dụng serverless. AWS CloudFormation là một dịch vụ giúp bạn lập mô hình và thiết lập các tài nguyên Amazon Web Services để bạn có thể dành ít thời gian hơn cho việc quản lý các tài nguyên đó và nhiều thời gian hơn để tập trung vào các ứng dụng chạy trong AWS của bạn. Bạn tạo một mẫu ( Template ) mô tả tất cả các tài nguyên AWS mà bạn muốn (như các hàm Lambda và nhóm S3) và AWS CloudFormation sẽ đảm nhận việc cung cấp và cấu hình các tài nguyên đó cho bạn.\nNgoài ra, bạn có thể sử dụng AWS Serverless Application Model (SAM) để thể hiện các tài nguyên bao gồm ứng dụng serverless. Các loại tài nguyên này, chẳng hạn như các hàm và API của AWS Lambda, được AWS CloudFormation hỗ trợ đầy đủ và giúp bạn xác định và triển khai ứng dụng serverless của mình dễ dàng hơn.\nTrong phần này, bạn sẽ sử dụng AWS CLI và AWS CloudFormation/SAM để đóng gói ứng dụng và triển khai nó từ đầu mà không cần phải tạo hoặc định cấu hình bất kỳ phần phụ thuộc nào theo cách thủ công.\nTrong Eclipse IDE, click chuột phải vào project TestLambda Click New Click File Tại mục File name, điền template.yaml Click Finish File template.yaml sẽ nằm cùng cấp với file pom.xml của project TestLambda Thay nội dung file template.yaml bằng nội dung dưới đây AWSTemplateFormatVersion: \u0026#39;2010-09-09\u0026#39; Transform: \u0026#39;AWS::Serverless-2016-10-31\u0026#39; Description: Testing lambda and S3 Resources: TestLambda: Type: \u0026#39;AWS::Serverless::Function\u0026#39; Properties: Handler: idevelop.lambda.s3handler.LambdaFunctionHandler Runtime: java8 CodeUri: target/s3handler-1.0.0.jar Description: Testing lambda and S3 MemorySize: 512 Timeout: 15 Role: !Sub arn:aws:iam::${AWS::AccountId}:role/LambdaRole Events: CreateThumbnailEvent: Type: S3 Properties: Bucket: Ref: ImageManagerSrcBucket Events: - \u0026#39;s3:ObjectCreated:Put\u0026#39; Filter: S3Key: Rules: - Name: prefix Value: uploads/ ImageManagerSrcBucket: Type: AWS::S3::Bucket Properties: BucketName: !Sub idevelop-imagemanager-${AWS::AccountId} Lưu lại Chúng ta sẽ sử dụng AWS CLI để đẩy tập tin template.yaml lên S3 bucket nơi mà nó có thể được triển khai. Trong Command prompt, chạy câu lệnh dưới đây aws cloudformation package --template-file template.yaml --s3-bucket \u0026lt;YOUR_CODE_BUCKET_NAME\u0026gt; --output-template deploy-template.yaml --profile devaxacademy Thay \u0026lt;YOUR_CODE_BUCKET_NAME\u0026gt; bằng tên S3 bucket có tên bắt đầu bằng idevelop-sourcecode chúng ta đã tạo\nNếu bạn thấy một thông báo lỗi ‘NoneType’ object has no attribute ‘items’ hãy kiểm tra lại format của tập tin template.yaml\nCâu lệnh aws cloudformation package sẽ lấy mẫu AWS SAM được cung cấp và viết lại nó trong định nghĩa của artifact được tự động tải lên S3 bucket. Trong trường hợp này, deploy-template.yaml được tạo và chứa giá trị CodeUri trỏ đến tập tin zip triển khai trong Amazon S3. Mẫu này đại diện cho ứng dụng serverless của bạn\n5. Bây giờ bạn đã sẵn sàng triển khai tập tin JAR dưới dạng một hàm Lambda và kết nối S3 trigger vào một S3 bucket mới. Bạn sẽ nhận thấy kết quả từ lệnh trước đó hướng dẫn chúng ta những gì cần chạy để triển khai mẫu đóng gói.\nTrong Command prompt, chạy câu lệnh dưới đây aws cloudformation deploy --template-file deploy-template.yaml --stack-name ImageManagerDemo --profile devaxacademy 6. Truy cập Amazon CloudFormation Console.\nClick Stacks Nhập ImageManagerDemo vào thanh tìm kiếm và nhấn Enter Chúng ta sẽ thấy CloudFormation stack có tên ImageManagerDemo được tạo Bạn có thể xem quá trình tạo tài nguyên trực tiếp trong bảng điều khiển CloudFormation. CloudFormation template tạo một S3 Bucket có tên idevelop-imagemanager-\u0026lt;YOUR_ACCOUNT_ID\u0026gt; trong đó \u0026lt;YOUR_ACCOUNT_ID\u0026gt; là AWS account ID của bạn.\nTemplate cũng tạo một hàm Lambda mới có tên là ImageManagerDemo-TestLambda-XXXXXX trong đó XXXXXX là một mã định danh ngẫu nhiên được CloudFormation phân bổ để đảm bảo tính duy nhất của tên hàm.\nTruy cập AWS S3 Console Nhập idevelop-imagemanager vào ô tìm kiếm Click S3 bucket idevelop-imagemanager-\u0026lt;YOUR_ACCOUNT_ID\u0026gt; Click Create folder Tại mục Folder name, nhập uploads Click Create folder Click thư mục uploads/ Click Upload Click Add files Chọn file Puppy.jpg chúng ta đã tải về CLick Add files Chọn file bất kỳ không phải ảnh Click Upload Click Close Chúng ta sẽ thấy tệp tin không phải hình ảnh chúng ta tải lên đã bị xóa. Click idevelop-imagemanager-\u0026lt;YOUR_ACCOUNT_ID\u0026gt; Click thư mục processed Chúng ta sẽ thấy hình ảnh thu nhỏ của tệp tin Puppy.jpg Truy cập Amazon CloudFormation Console. Click Stacks Nhập ImageManagerDemo vào thanh tìm kiếm và nhấn Enter Click tên của CloudFormation stack Click Monitor Click View logs in CloudWatch Click Log stream đầu tiên trong bảng Log streams Chúng ta hãy xem quá trình thực hiện như thế nào trong CloudWatch log "},{"uri":"https://hotloncon1.github.io/aws-lab000052/vi/4-extending-serverless-microservices/4.3-update-lambda-function/","title":"(Optional) Cập nhật quyền của hàm Lambda ","tags":[],"description":"","content":"(Optional) Cập nhật quyền của hàm Lambda Truy cập AWS Lambda Console Click Functions. Nhập ImageManagerDemo vào ô tìm kiếm và nhấn Enter. Click tên của Lambda Function Chúng ta thấy rằng S3 trigger không xuất hiện mặc dù hàm vẫn chạy như mong muốn. Bởi vì hàm Lambda không biết về S3 bucket trigger - S3 biết về hàm Lambda mà nó sẽ kích hoạt khi một sự kiện diễn ra nhưng ngược lại thì không. Chạy lệnh sau để S3 trigger xuất hiện trong AWS Lambda aws lambda add-permission --function-name \u0026lt;REPLACE_LAMBDA_FUNCTION_NAME\u0026gt; --region \u0026lt;REPLACE_REGION\u0026gt; --statement-id PolicyDocument --action \u0026#34;lambda:InvokeFunction\u0026#34; --principal s3.amazonaws.com --source-arn arn:aws:s3:::\u0026lt;REPLACE_S3_BUCKET_NAME\u0026gt; --source-account \u0026lt;REPLACE_AWS_ACCOUNT_ID\u0026gt; --profile Thay \u0026lt;REPLACE_LAMBDA_FUNCTION_NAME\u0026gt; bằng tên của Lambda Function có tên bắt đầu bằng ImageManagerDemo-TestLambda (tên của Lambda Function được tạo từ CloudFomation trong phần 4.2) Thay \u0026lt;REPLACE_S3_BUCKET_NAME\u0026gt; bằng idevelop-imagemanager-\u0026lt;YOUR_ACCOUNT_ID\u0026gt; (tên của S3 bucket được tạo từ CloudFomation trong phần 4.2) Thay \u0026lt;REPLACE_AWS_ACCOUNT_ID\u0026gt; bằng AWS Account Id của bạn\n3. Kiểm tra lại, chúng ta sẽ thấy S3 trigger xuất hiện. "},{"uri":"https://hotloncon1.github.io/aws-lab000052/vi/5-use-codestar-orchestration/5.3-update-target-region/","title":"Cập nhật target region cho API ","tags":[],"description":"","content":"Cập nhật target region cho API Tập tin swagger.yml định nghĩa API được dùng cho microservice thông qua Amazon API Gateway. Chúng cần được cập nhật chi tiết AWS Account ID và target AWS Region trước khi triển khai microservice.\nTrong Eclipse IDE, mở tập tin swagger.yml Nhấn tổ hợp phím Ctrl+F Tại mục Find, điền \u0026lt;REGION\u0026gt; Tại mục Replace with, điền Region của bạn Click Replace All để thay thế Làm tương tự bước 1 để thay thế \u0026lt;ACCOUNTID\u0026gt; bằng AWS Account Id của bạn Lưu lại Tromg Command Prompt, chạy câu lệnh dưới đây để cấu hình email và username cho git C:\\Users\\Administrator\\git\\dev-flight-svc\u0026gt;git config --global user.name \u0026#34;awsstudent\u0026#34; C:\\Users\\Administrator\\git\\dev-flight-svc\u0026gt;git config --global user.email \u0026#34;\u0026lt;YOUR_EMAIL\u0026gt;\u0026#34; Thay \u0026lt;YOUR_EMAIL\u0026gt; bằng email của bạn\n4. Chạy lệnh dưới đây để xem lại thay đổi chưa được commit\ngit status 5. Chạy lệnh dưới đây để thêm những tập tin thay đổi\ngit add . git commit -m \u0026#34;Baseline implementation\u0026#34; 6. Chạy lệnh dưới đây để trở về nhánh master\ngit checkout master 7. Chạy lệnh dưới đây để merge thay đổi từ nhánh new-implementation vào nhánh master\ngit merge new-implementation 8. Trong Eclipse IDE, nhấp chuột phải vào project dev-flight-svc\nClick Team Click Push to origin. Click Close Truy cập Amazon EC2 console. Click Security Groups. Nhập DBSecurityGroup vào thanh tìm kiếm và nhấn Enter Chọn DBSecurityGroup Click tab Inbound rules Click Edit inbound rules Trong phần Source, chọn DBSecurityGroup Click Save rules Truy cập AWS CodeStar Console. Click Projects Click dev-flight-svc Click View application Khi trang được mở, bạn sẽ thấy một thông báo lỗi {“message”:“Missing Authentication Token”}. Điều này xảy ra vì bạn đang cố gắng truy cập vào gốc của API, thay vì một microservice cụ thể. Chỉnh sửa URL, thêm flightspecials vào cuối URL Chúng ta sẽ được kết quả như sau "},{"uri":"https://hotloncon1.github.io/aws-lab000052/vi/2-prepare/2.3-connectvirtualmachine/","title":"Kết nối Windows instance","tags":[],"description":"","content":"Kết nối Windows instance Truy cập Amazon EC2 console. Trên thanh điều hướng bên trái, chọn Intances. Gõ DevAxWindowsHost vào ô tìm kiếm. Nhấn Enter Chọn DevAxWindowsHost. Click Connect. Tại trang Connect to instance Click tab RDP client. Click Download remote desktop file. Chúng ta sẽ download file remote desktop xuống đường dẫn thư mục chứa key pair. Click Get password. Tại trang Get Windows password: Click Browse. Chọn file KPforDevAxInstances.pem đã tải về trong phần 2.1. Click Decrypt Password để giải mã thông tin password. Copy password đã được giải mã. Mở file DevAxWindowsHost.rdp bạn đã tải về trong bước 2. Click Connect. Điền thông tin password đã copy trong bước 4 Click OK. Click Don’t ask me again for connections to this computer. Click Yes. Bạn đã kết nối thành công. Cấu hình AWS CLI Gán quyền Administrator Access vào user awsstudent được tạo bởi Cloud Formation template Truy cập vào AWS IAM Console. Click Users. Gõ awsstudent vào ô tìm kiếm Click user awsstudent Trong phần Permissions policies Click Add permissions Trong trang Add permissions to awsstudent Click Attach existing policies directly Gõ AdministratorAccess vào ô tìm kiếm. Chọn AdministratorAccess Click Next:Review Click Add Permission Click tab Security credentials Click Create access key để tiến hành tạo access key Click Download .csv file để lưu thông tin Access key và Secret access key để phục vụ cho bước tiếp theo Chạy lệnh dưới đây aws configure set profile.devaxacademy.region \u0026lt;your_region\u0026gt; aws configure set profile.devaxacademy.aws_access_key_id \u0026lt;access_key_id\u0026gt; aws configure set profile.devaxacademy.aws_secret_access_key \u0026lt;secret_access_key\u0026gt; Thay \u0026lt;your_region\u0026gt; bằng Region code của bạn Thay \u0026lt;access_key_id\u0026gt; bằng Access Key Id bạn đã lưu về trong bước 6\nThay \u0026lt;secret_access_key\u0026gt; bằng Secret Access Key bạn đã lưu về trong bước 6\nCấu hình Eclipse IDE Mở Eclipse IDE trong máy ảo Windows. Trong lần đầu tiên khởi động, Eclipse sẽ hỏi bạn cấu hình workspace. Click Use this as the default and do not ask again CLick Launch Click Finish cho cửa sổ thu thập thông tin của AWS Toolkit Click nút Restore. Tìm biểu tượng AWS, nhấp vào mũi tên thả xuống Click Preferences\u0026hellip; Tại mục Default Profile, chọn devaxacademy Click Apply and Close "},{"uri":"https://hotloncon1.github.io/aws-lab000052/vi/3-create-serverless-microservices/","title":"Tạo một microservice","tags":[],"description":"","content":"Tổng quan Trong phần này, chúng ta sẽ tạo một Java serverless microservice sử dụng AWS Lambda. Chúng ta sẽ sử dụng AWS Eclipse Toolkit để tải Java Lambda template như một điểm bắt đầu. Chúng ta sẽ sử dụng điểm này để phát triển microservice của chúng ta. Microservice sẽ quản lý và tự động tạo hình thu nhỏ cho S3 bucket. Chúng ta sẽ mở rộng microservice này trong phần tiếp theo.\nNội dung: Tạo và kiểm tra hàm Lambda tại cục bộ Tải lên và kiểm tra hàm Lambda trong AWS Lambda "},{"uri":"https://hotloncon1.github.io/aws-lab000052/vi/2-prepare/2.4-setups3/","title":"Cài đặt S3 buckets","tags":[],"description":"","content":"Cài đặt S3 buckets Bạn cần cài đặt 2 buckets. Một bucket sẽ chứa hàm lambda được tải lên và một bucket được sử dụng để lưu trữ hình ảnh. Bạn có thể sử dụng AWS Console hoặc dùng command line để tạo S3 buckets.\nTruy cập máy ảo window, mở command prompt Chạy lệnh dưới đây để tạo một S3 bucket để lưu hàm Lambda và một bucket để chứa hình ảnh tải lên aws s3 mb s3://idevelop-sourcecode-\u0026lt;yourinitials\u0026gt; --region \u0026lt;region\u0026gt; --profile devaxacademy aws s3 mb s3://idevelop-imagemanager-\u0026lt;yourinitials\u0026gt; --region \u0026lt;region\u0026gt; --profile devaxacademy Thay \u0026lt;yourinitials\u0026gt; bằng tên của bạn để tạo ra tên duy nhất cho S3 bucket.\nThay \u0026lt;region\u0026gt; bằng region bạn đang làm bài thực hành này.\n3. Truy cập AWS S3 Console.\nGõ idevelop vào ô tìm kiếm, chúng ta sẽ thấy 2 S3 bucket "},{"uri":"https://hotloncon1.github.io/aws-lab000052/vi/4-extending-serverless-microservices/","title":"Mở rộng Serverless Microservices","tags":[],"description":"","content":"Tổng quan Trong phần này, bạn sẽ sử dụng Eclipse IDE để chỉnh sửa mã nguồn và triển khai lại hàm Lambda bằng Eclipse IDE.\nNội dung: Triển khai hàm Lambda ImageManager Tự động hóa Serverless Microservice (Optional) Cập nhật quyền của hàm Lambda "},{"uri":"https://hotloncon1.github.io/aws-lab000052/vi/5-use-codestar-orchestration/","title":"Cấu hình điều phối với CodeStar","tags":[],"description":"","content":"Tổng quan Trong phần này, chúng ta sẽ tự động hóa việc triển khai Lambda serverless microservice với AWS CodeStar.\nNội dung: Tạo nhánh mới Triển khai lại thông qua CI/CD pipeline Cập nhật target region cho API "},{"uri":"https://hotloncon1.github.io/aws-lab000052/vi/6-challenge/","title":"Thử thách - Expose microservice API","tags":[],"description":"","content":"Thử thách - Expose microservice API HotelSpecial class HotelSpecial.java (1 KB) Sao chép tập tin HotelSpecial.java vào đường dẫn …/src/main/java/devlounge/model trong project dev-flight-svc template file template.yml (6 KB) Thay nội dung của file template.yml trong project dev-flight-svc bằng nội dung của file template.yml bên trên Làm tương tự bước 11, 12, 13, 14 và 15 trong phần 5.2 để cập nhật các giá trị trong file template.yml trong project dev-flight-svc swagger file swagger.yml (4 KB) Thay nội dung của file swagger.yml trong project dev-flight-svc bằng nội dung của file swagger.yml bên trên Làm tương tự bước 1 và 2 trong phần 5.3 để cập nhật các giá trị của file swagger.yml trong project dev-flight-svc Trong Command Prompt, chuyển đường dẫn đến project dev-flight-svc Chạy câu lệnh dưới đây để commit những thay đổi git add . git commit -m \u0026#34;Update implementation\u0026#34; Trong Eclipse IDE, nhấp chuột phải vào project dev-flight-svc Click Team Click Push to origin. Click Close Truy cập AWS CodeStar Console. Click Projects Click dev-flight-svc Click View application Thêm hotelspecials vào cuối URL và nhấn Enter Chúng ta sẽ được kết quả như sau. Bài tập nâng cao tùy chọn Sửa đổi mã nguồn từ phần 3 để phát hiện các loại file khác nhau và xử lý chúng theo cách tùy chọn (ví dụ, chặn và di chuyển chúng tới một thư mục khác) Tạo một hàm Lambda mới thực hiện các task mỗi phút một lần. Task có thể đơn giản như ghi kết quả đầu ra vào CloudWatch Logs. "},{"uri":"https://hotloncon1.github.io/aws-lab000052/vi/7-cleanup/","title":"Dọn dẹp tài nguyên","tags":[],"description":"","content":"Bạn sẽ dọn dẹp tài nguyên theo thứ tự sau:\nTerminate EC2 Instance Truy cập Amazon EC2 console. Trên thanh điều hướng bên trái, click Intances. Chọn DevAxWindowsHost. Click Instance state Click Terminate instance Click Terminate Xóa Users Truy cập vào AWS IAM Console. Click Users. Nhập awsstudent vào thanh tìm kiếm và nhấn Enter Chọn awsstudent. Click Delete Điền awsstudent để xác nhận, sau đó click Delete Xóa CodeStar Truy cập AWS CodeStar Console. Click Projects Chọn dev-flight-svc Click Delete Điền delete để xác nhận, sau đó click Delete để xóa Xóa S3 bucket Truy cập vào AWS S3 Console. Click Buckets Chọn S3 bucket có tên bắt đầu bằng idevelop-sourcecode-. Click Empty. Điền permanently delete để xác nhận, sau đó click Empty để xóa toàn bộ dữ liệu trong S3 bucket. Click Exit để trở lại giao diện S3. Chọn S3 bucket có tên bắt đầu bằng idevelop-sourcecode-. Click Delete. Điền tên bucket sau đó click Delete bucket để xóa S3 bucket. Làm tương tự cho các S3 bucket còn lại Xóa CloudFormation Stack Truy cập AWS CloudFormation Console. Chọn aws-stack-for-Devax-lab03. Click Delete Click Delete stack Xóa Lambda function Truy cập AWS Lambda console. Click Functions. Chọn TestLambda. Click Actions Click Delete Điền delete để xác nhận, sau đó click Delete để xóa Xóa RDS Snapshot Truy cập AWS RDS console. Click Snapshots Chọn RDS Snapshot đã được tạo trong bài lab này Click Actions Click Delete snapshot Click Delete để xóa "},{"uri":"https://hotloncon1.github.io/aws-lab000052/vi/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://hotloncon1.github.io/aws-lab000052/vi/tags/","title":"Tags","tags":[],"description":"","content":""}]